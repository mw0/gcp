"""@package graphlab.connect.aws.ec2

This module makes it easy to have a GraphLab server running on an EC2 instance.
"""

'''
Copyright (C) 2015 Dato, Inc.
All rights reserved.

This software may be modified and distributed under the terms
of the BSD license. See the DATO-PYTHON-LICENSE file for details.
'''

import ConfigParser
import json
import logging
import os
import time
import urllib2

import boto.ec2
from boto.exception import EC2ResponseError

import graphlab.product_key
import graphlab.connect.server as glserver
import graphlab.connect.main as glconnect
from graphlab.connect.main import __catch_and_log__

from graphlab.cython.cy_ipc import PyCommClient as Client
from graphlab.cython.cy_ipc import get_public_secret_key_pair

from graphlab_util.config import DEFAULT_CONFIG as config
from graphlab.connect import _get_metric_tracker
from graphlab.util import _get_aws_credentials as get_credentials


CONFIG_SECTION = 'AWS'
DEFAULT_CIDR_RULE = '0.0.0.0/0'  # Open to the entire internet.
DEFAULT_INSTANCE_TYPE = 'm3.xlarge'
JSON_BLOB_PATH_FORMAT = "/gl_api/api/v1/cloud/aws/instances/%s?client_version=%s&region=%s&product_key=%s"
GRAPHLAB_NAME = 'GraphLab'
VALID_REGIONS = [r.name for r in boto.ec2.get_regions('ec2')]

# Port 9000 & 9001 - used when running in server mode: only server running with external client.
# Port 9002 & 9003 - used for metrics (deprecated).
# Port 9004 - old commander daemon for jobs/tasks (deprecated).
# Port 9005 - (was used for predictive service/web service. It is the default port used if user does not specify any port))
# Port 9006 - used by predictive service (reddis).
# Port 9007 - old worker daemon for jobs/tasks (deprecated).
# Port 9000 - 9200 - new commander worker
GRAPHLAB_PORT_MIN_NUM = 9000
GRAPHLAB_PORT_MAX_NUM = 9200
ADDITIONAL_REDIS_PORT = 19006

# Swallow all boto logging, except critical issues
logging.getLogger('boto').setLevel(logging.CRITICAL)

__LOGGER__ = logging.getLogger(__name__)

class LicenseValidationException(Exception):
    pass

class _Ec2Instance:
    def __init__(self, public_dns_name, instance_id, instance, region):
        self.public_dns_name = public_dns_name
        self.instance_id = instance_id
        self.instance = instance
        self.region = region

    def stop(self):
        _stop_instances([self.instance_id], self.region)


def _get_region_from_config(config_path = (os.path.join(os.path.expanduser("~"), ".graphlab", "config"))):
    result = None
    if (os.path.isfile(config_path)):
        config = ConfigParser.ConfigParser()
        config.read(config_path)
        if(config.has_section(CONFIG_SECTION) and config.has_option(CONFIG_SECTION, 'region')):
            result = config.get(CONFIG_SECTION, 'region')
    return result


def set_credentials(access_key_id, secret_access_key):
    """
    Sets the AWS credential environment variables.

    Helper function to set the following environment variables: AWS_ACCESS_KEY_ID and
    AWS_SECRET_ACCESS_KEY. You are also free to set these environment variables directly.

    Parameters
    ----------
    access_key_id : str
        Value for the AWS_ACCESS_KEY_ID environment variable.

    secret_access_key : str
        Value for the AWS_SECRET_ACCESS_KEY environment variable.

    See Also
    --------
    get_credentials

    Examples
    --------
    >>> graphlab.aws.set_credentials('RBZH792CTQPP7T435BGQ', '7x2hMqplWsLpU/qQCN6xAPKcmWo46TlPJXYTvKcv')

    """
    os.environ['AWS_ACCESS_KEY_ID'] = str(access_key_id)
    os.environ['AWS_SECRET_ACCESS_KEY'] = str(secret_access_key)


@__catch_and_log__
def list_instances(region='us-west-2'):
    """
    Instance IDs for all active GraphLab EC2 hosts. Returns instance IDs for all
    active GraphLab EC2 hosts (for the specified region), not just the instance
    ID associated with the current python session.

    Parameters
    ----------
    region : string, optional
        The `AWS region
        <http://docs.aws.amazon.com/general/latest/gr/rande.html#ec2_region>`_
        in which to list instances. Default is 'us-west-2'.

    Returns
    -------
    out : list[string]
        A list of AWS instance IDs corresponding to active instances in the
        specified region.

    Examples
    --------
    .. sourcecode:: python

        # No instances running in 'us-west-2'.
        >>> graphlab.aws.list_instances()
        []

        # Two insances running in 'us-east-1'.
        >>> graphlab.aws.list_instances(region = 'us-east-1')
        [u'i-8df559a7', u'i-ed2aa9c1']
    """

    __LOGGER__.info("Listing instances in %s." % region)
    aws_connection = boto.ec2.connect_to_region(region)
    recent_ids = [i.res_id for i in aws_connection.get_all_tags(filters={'tag:GraphLab': ''})]
    active_instnaces = aws_connection.get_all_instance_status(instance_ids=recent_ids)
    return [i.id for i in active_instnaces]


def _stop_instances(instance_id_list, region, credentials = {}):
    __LOGGER__.info("Terminating EC2 host(s) %s in %s" % (instance_id_list, region))

    # Hopefully we will not need this string
    ERROR_MSG = 'Invalid response from EC2. Unable to terminate host(s). Please terminate using the ' \
        'AWS EC2 Console.'

    try:
        # Shut the host(s) down.
        conn = boto.ec2.connect_to_region(region, **credentials)
        response = conn.terminate_instances(instance_ids = instance_id_list)

        # Sanity check response.
        if(not(len(response) == len(instance_id_list))):
            raise Exception(ERROR_MSG)

         # it is possible the instances are still being terminated, but we do
         # not need to wait for that now.
        return
    except:
        raise Exception(ERROR_MSG)

def _authorize_for_security_group(security_group, ip_protocol, from_port, to_port,
                                  cidr_ip=None, src_group=None):
    # Note that this will throw an exception if this particular set of ports was already authorized in the security group.
    try:
        security_group.authorize(ip_protocol, from_port, to_port, cidr_ip, src_group)
    except EC2ResponseError as e:
        if not "<Code>InvalidPermission.Duplicate</Code>" in str(e):
            raise e

def _ec2_factory(instance_type, region=None, availability_zone=None,
                 CIDR_rule=None, security_group_name=None, tags=None,
                 user_data = {}, credentials = {}, ami_service_parameters = {},
                 num_hosts = 1, additional_port_to_open=None):
    '''
    This function does everything necessary to bring up EC2 host(s): create a security group (if
    nessary), determine arguments to start up the EC2 instance (i.e. AMI id and user data),
    actually start up the EC2 instance, wait for it, and applies AWS tags.
    '''
    # Get and validate the product key
    product_key = graphlab.product_key.get_product_key()
    license_info = graphlab.product_key._get_license_info()
    if (not graphlab.product_key._is_product_key_valid(product_key, license_info)):
        raise LicenseValidationException("Product Key validation failed, please confirm your product key is correct.\
 If you believe this key to be valid, please contact support@dato.com")

    # Set default values for parameters.
    if(region is None):
        region = _get_region_from_config()
        if(region is None):
            region = 'us-west-2'
        else:
            __LOGGER__.info('Read region from config file.')

    if (region not in VALID_REGIONS):
        raise Exception("%s is not a valid region." % region)

    # If a CIDR rule is specified, a security group must also be specified.
    if CIDR_rule is not None and security_group is None:
        # TODO: I think we should re-examine this. I don't think it needs to be requirement.
        __LOGGER__.error('If you specify a CIDR rule, you must also specify an existing security group.')
        return
    # If no security group is specified (and no CIDR rule), use a default value for the security group name.
    elif security_group_name is None:
        security_group_name = GRAPHLAB_NAME
    if CIDR_rule is None:
        CIDR_rule = DEFAULT_CIDR_RULE

    # Setup/get the security group.
    try:
        conn = boto.ec2.connect_to_region(region, **credentials)
        # Does the security group already exist?
        security_group = None
        for sg in conn.get_all_security_groups():
            if(security_group_name == sg.name):
                security_group = sg
                break   # found it
    except boto.exception.EC2ResponseError as e:
        # This is the first AWS contact, so the most likely cause is env vars aren't set.
        __LOGGER__.debug('EC2 Response Error: %s' % e)
        raise Exception('EC2 response error. Please verify your AWS credentials. To configure your '
                'AWS credentials use graphlab.aws.set_credentials or set the '
                'AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY environment variables'
                'Exception: %s' % e)
    except boto.exception.NoAuthHandlerFound as e:
        raise Exception('AWS configuration not found. Please configure your AWS credentials '
                'using graphlab.aws.set_credentials or by setting AWS_ACCESS_KEY_ID '
                'and AWS_SECRET_ACCESS_KEY environment variables')

    # If security group doesn't exist, create it.
    if security_group is None:
        security_group = conn.create_security_group(security_group_name,
                'Only open ports needed for GraphLab Server')

    # Configure the security group
    # Allow all traffic between hosts in same security group.
    _authorize_for_security_group(security_group = security_group,
               ip_protocol = 'tcp',
               from_port = 0,
               to_port = 65535,
               src_group = security_group)

    # Ports open externally.
    _authorize_for_security_group(security_group = security_group,
               ip_protocol = 'tcp',
               from_port = GRAPHLAB_PORT_MIN_NUM,
               to_port = GRAPHLAB_PORT_MAX_NUM,
               cidr_ip = CIDR_rule)

    if additional_port_to_open is not None:
        _authorize_for_security_group(security_group = security_group,
                   ip_protocol = 'tcp',
                   from_port = additional_port_to_open,
                   to_port = additional_port_to_open,
                   cidr_ip = CIDR_rule)
    _authorize_for_security_group(security_group = security_group,
               ip_protocol = 'tcp',
               from_port = 443,
               to_port = 443,
               cidr_ip = CIDR_rule)
    _authorize_for_security_group(security_group = security_group,
               ip_protocol = 'tcp',
               from_port = 80,
               to_port = 80,
               cidr_ip = CIDR_rule)
    _authorize_for_security_group(security_group = security_group,
               ip_protocol = 'tcp',
               from_port = ADDITIONAL_REDIS_PORT,
               to_port = ADDITIONAL_REDIS_PORT,
               cidr_ip = CIDR_rule)

    # Determine AMI id, as well as engine, os URL, and hash value
    if ('GRAPHLAB_TEST_AMI_ID' in os.environ and 'GRAPHLAB_TEST_ENGINE_URL' in os.environ and 'GRAPHLAB_TEST_HASH_KEY' in os.environ):
        # unit-test mode, don't involve webservice to retrieve AMI, instead use environment variables
        ami_id = os.environ['GRAPHLAB_TEST_AMI_ID']
        engine_url = os.environ['GRAPHLAB_TEST_ENGINE_URL']
        __LOGGER__.info("UNIT mode, using AMI: '%s' and engine url: '%s' when launching EC2 instance." % (ami_id, engine_url))
        json_blob = json.loads('{}')
        json_blob['ami_id'] = ami_id
        json_blob['engine_url'] = engine_url
        json_blob['hash_key'] = os.environ['GRAPHLAB_TEST_HASH_KEY']
    else:
        # Get the info to start a EC2 from the GraphLab Server
        json_blob_path = JSON_BLOB_PATH_FORMAT % (instance_type, config.version, region, product_key)
        for (param_name, param_value) in ami_service_parameters.items():
            json_blob_path += "&%s=%s" % (str(param_name), str(param_value))
        json_blob_url = config.graphlab_server + json_blob_path

        try:
            # set specific timeout for this web service request, lots of time spent in SSL negotiation
            # for staging server allows a little more time
            timeout_in_seconds = 10 if config.mode == 'PROD' else 60
            graphlab_server_response = urllib2.urlopen(json_blob_url, timeout=timeout_in_seconds)
            json_blob = json.loads(graphlab_server_response.read())
        except:
            raise Exception('Unable to successfully retrieve correct EC2 image to launch for this '
                    'version. This could be a temporary problem. Please try again in a few '
                    'minutes. If the problem persists please contact support@dato.com')
        __LOGGER__.debug("web service return: %s" % json_blob)

        if json_blob.get('error'):
            raise LicenseValidationException(json_blob.get('error'))

    if 'ami_id' not in json_blob or json_blob['ami_id'] is None:
        raise Exception("Unable to successfully retrieve correct EC2 image to launch. Please try "
                "again later or contact support@dato.com. Error received:'%s'"
                % json_blob.get('message'))
    ami_id = json_blob['ami_id']

    # Add json_blob to user_data and set the product key and hash key
    user_data.update(json_blob)
    user_data['product_key'] = product_key

    user_data['hash_key'] = json_blob.get('hash_key', 'NO_HASH_VALUE')

    # Check for empty os_url
    if user_data.get('os_url') is None or len(user_data.get('os_url')) == 0:
        user_data['os_url'] = 'NO_OS_URL'


    # Check for testing override of os_url param.
    if ('GRAPHLAB_TEST_OS_URL' in os.environ):
        user_data['os_url'] = os.environ['GRAPHLAB_TEST_OS_URL']

    run_instances_args =  {
            'security_group_ids' : [ security_group_name ],
            'user_data' : json.dumps(user_data),
            'instance_type' : instance_type,
            'placement' : availability_zone
            }

    if num_hosts != 1:
        run_instances_args['min_count'] = num_hosts
        run_instances_args['max_count'] = num_hosts

    if 'GRAPHLAB_TEST_EC2_KEYPAIR' in os.environ:
        keypair = os.environ['GRAPHLAB_TEST_EC2_KEYPAIR']
        __LOGGER__.info("Using keypair: '%s' when launching EC2 instance" % (keypair))
        run_instances_args['key_name'] = keypair

    # Actually launch the EC2 instance(s) and wait for them to start running.
    instances = None
    try:
        response = conn.run_instances(ami_id, **run_instances_args)
        instances = response.instances
        if(len(response.instances) != num_hosts):
            raise Exception

        # Report
        for i in instances:
            __LOGGER__.info("Launching an %s instance in the %s availability zone, with id: %s."
                    " You will be responsible for the cost of this instance."
                    % (i.instance_type, i.placement, i.id))

        # Wait for all host(s) to say they're done starting up.
        while True:
            try:
                for i in instances:
                    # Rarely an instance can a reach temp state before going into pending. We check for
                    # 'running' right away to make unit tests work.
                    while not i.update() in ['pending', 'running', 'failed']:
                        time.sleep(1)
                    while i.update() == 'pending':
                        time.sleep(1)
                    if i.update() == 'failed':
                        raise RuntimeError("Instance %s startup failed" % i.id)
                break
            except EC2ResponseError as e:
                # EC2 is eventual consistence so sometimes it complains that it
                # cannot find the instance, in that case, we will retry
                __LOGGER__.debug("Ignoring EC2ResponseError: %s" % e.message)

    except Exception as e:
        if instances:
            _stop_instances([i.id for i in instances] , self.region)
        raise Exception("Unable to launch EC2 instance: '%s'. Please check AWS Console to make "
                " sure any EC2 instances launched have been terminated." % e)

    # Add tags to this instance(s).
    if(tags is None):
        tags = {}
    tags[GRAPHLAB_NAME] = ''
    for i in instances:
        conn.create_tags(i.id, tags)

    results = []
    for i in instances:
        results.append(_Ec2Instance(i.public_dns_name, i.id, i, region))

    if num_hosts == 1:
        # for backward compatibility
        return results[0]
    return results


def _get_ec2_instances(ec2_id_list, region, aws_credentials = {}):
    conn = boto.ec2.connect_to_region(region, **aws_credentials)
    response = conn.get_all_instances(instance_ids = ec2_id_list)

    results = []
    for reservation in response:
        results += reservation.instances

    return results
